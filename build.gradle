buildscript {

    repositories {
    
        jcenter()
        
        maven { 
        
            url = 'http://files.minecraftforge.net/maven'
        }
        
        maven {

            url 'https://plugins.gradle.org/m2/'
        }
    }
    
    dependencies {
    
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
    }
}

plugins {

   id 'com.matthewprenger.cursegradle' version '1.1.0'
}

apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: 'com.matthewprenger.cursegradle'
apply plugin: 'maven-publish' 

apply from: 'https://raw.githubusercontent.com/MinecraftModDevelopment/Gradle-Collection/master/generic/secrets.gradle'
apply from: 'https://raw.githubusercontent.com/MinecraftModDevelopment/Gradle-Collection/master/generic/patreon.gradle'
apply from: 'https://raw.githubusercontent.com/MinecraftModDevelopment/Gradle-Collection/master/generic/markdown-git-changelog.gradle'
apply from: 'https://raw.githubusercontent.com/MinecraftModDevelopment/Gradle-Collection/master/minecraft/artifacts.gradle'
apply from: 'https://raw.githubusercontent.com/MinecraftModDevelopment/Gradle-Collection/master/minecraft/maven.gradle'

if (project.hasProperty('secretFile')) {

    loadSecrets(new File((String) findProperty('secretFile')))
}

version = "${mod_version}" + getBuildNumber()
group = "${mod_group}"
archivesBaseName = "${mod_name}-${version_minecraft}"

sourceCompatibility = 1.8
targetCompatibility = 1.8

minecraft {

    version = "${version_minecraft}-${version_forge}"
    mappings = "${version_mcp}"
    runDir = 'run'
    
    replace '@VERSION@', project.version
    replace '@FINGERPRINT@', project.findProperty('signSHA1')
    replaceIn "${mod_class}.java"
}

repositories {

    maven {

        url "http://maven.mcmoddev.com"
    }
    
    maven {
    
        url 'http://maven.blamejared.com'
    }
}

dependencies {

    deobfProvided "net.darkhax.bookshelf:Bookshelf-1.12.2:${version_bookshelf}"
    deobfProvided "CraftTweaker2:CraftTweaker2-MC1120-Main:1.12-${version_minetweaker}"
}

processResources {

    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {
    
        include 'mcmod.info'
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }
        
    from(sourceSets.main.resources.srcDirs) {
    
        exclude 'mcmod.info'
    }
    
    from 'LICENSE'
}

String getBuildNumber() {

    return System.getenv('BUILD_NUMBER') ? System.getenv('BUILD_NUMBER') : System.getenv('TRAVIS_BUILD_NUMBER') ? System.getenv('TRAVIS_BUILD_NUMBER') : '0';
}

//Shuts up javadoc failures
if (JavaVersion.current().isJava8Compatible()) {

    allprojects {

        tasks.withType(Javadoc) {

            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }
}

curseforge {
   
    apiKey = findProperty('curse_auth') ?: 0 
    def versions = "${curse_versions}".split(', ')

    project {

        id = "${curse_project}"
        releaseType = 'alpha'
        changelog = getGitChangelog() + "\n\nHuge thanks to my supporters on [Patreon](https://www.patreon.com/Darkhax?MCChangelog?${mod_class})\n\n" + getPledgeLog()
        changelogType = 'markdown'

        versions.each {

            addGameVersion "${it}"
        }

        if (project.hasProperty('curse_requirements') || project.hasProperty('curse_optionals')) {

            mainArtifact(jar) {

                relations {

                    if (project.hasProperty('curse_requirements')) {
                        def requirements = "${curse_requirements}".split(', ')
                        requirements.each {

                            requiredLibrary "${it}"
                        }
                    }

                    if (project.hasProperty('curse_optionals')) {
                        def optionals = "${curse_optionals}".split(', ')
                        optionals.each {

                            optionalLibrary "${it}"
                        }
                    }
                }
            }
        }

        addArtifact(sourcesJar)
        addArtifact(javadocJar)
        addArtifact(deobfJar)
    }
}

task signJar(type: SignJar, dependsOn: reobfJar) {

    onlyIf {
    
        project.hasProperty('keyStore')
    }
    
    keyStore = project.findProperty('keyStore')
    alias = project.findProperty('keyStoreAlias')
    storePass = project.findProperty('keyStorePass')
    keyPass = project.findProperty('keyStoreKeyPass')
    inputFile = jar.archivePath
    outputFile = jar.archivePath
}

build.dependsOn signJar

task recompress(type:Exec, dependsOn: jar) {
    
    commandLine 'advzip', '-z', '-4', '-i 8', jar.archivePath.toString()
}

task updateVersionTracker {

    onlyIf {
    
        project.hasProperty('versionTrackerAPI')
    }
    
    doLast {
        def body = [
            'author': "${project.findProperty('mod_vendor')}",
            'projectName': "${project.findProperty('mod_name').toLowerCase()}",
            'gameVersion': "${project.findProperty('version_minecraft')}",
            'projectVersion': "${version}",
            'homepage': "${project.findProperty('curse_page')}",
            'uid': "${project.findProperty('versionTrackerKey')}"
        ]
    
        // Opens a connection to the version tracker API and writes the payload JSON.
        def req = new URL(project.findProperty('versionTrackerAPI')).openConnection()
        req.setRequestMethod('POST')
        req.setRequestProperty('Content-Type', 'application/json; charset=UTF-8')
        req.setRequestProperty('User-Agent', "${project.findProperty('mod_name')} Tracker Gradle")
        req.setDoOutput(true)
        req.getOutputStream().write(JsonOutput.toJson(body).getBytes("UTF-8"))

        // We need to attempt a read in order to actually send the message.
        println "VersionCheck Status code: ${req.getResponseCode()}"
        println "VersionCheck Response: ${req.getInputStream().getText()}"
    }
}